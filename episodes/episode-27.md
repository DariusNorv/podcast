# Выпуск №27

Видео в iOS, ChakraCore конкурент V8, доступные модальные окна, таблицы и формы, чехарда с цветовыми функциями CSS.

[Слушайте на SoundCloud](https://soundcloud.com/web-standards/episode-27), [обсуждайте в Слаке](https://web-standards.slack.com/messages/podcast/).

## 00:26 События

- [MoscowJS №32](https://events.yandex.ru/events/yagosti/28-july-2016/)
- [Черновик расписания WSD](https://wsd.events/#calendar)
- [Первый WSD в Яндексе](https://events.yandex.ru/events/yagosti/wsd-msk-nov-2012/)
- [FrontTalks](http://fronttalks.ru/) 17—18 сентября

## 04:57 Инлайновое видео в iOS

- [New `<video>` Policies for iOS](https://webkit.org/blog/6784/new-video-policies-for-ios/)

## 08:09 ChakraCore на Mac и Linux

- [Bringing ChakraCore to Linux and OS X](https://blogs.windows.com/msedgedev/2016/07/27/chakracore-on-linux-osx/)
- [Why ChakraCore matters](https://www.christianheilmann.com/2016/07/27/why-chakracore-matters/)
- [nodejs/vm](https://github.com/nodejs/vm)
- [mozilla/spidernode](https://github.com/mozilla/spidernode)

## 25:12 Модальные окна

- [Оформление модальных окон](http://prgssr.ru/development/oformlenie-modalnyh-okon.html)

## 32:43 Сложные таблицы

- [Lessons from building mobile-friendly, accessible data tables](https://medium.com/p/1e05c6924eaf)

## 37:13 Формы и доступность

- [Using the fieldset and legend elements](https://accessibility.blog.gov.uk/2016/07/22/using-the-fieldset-and-legend-elements/)
- [Totally Tooling Tips](https://www.youtube.com/watch?v=pBJZsp5LsOE&index=2&list=PLNYkxOF6rcIB3ci6nwNyLYNU6RDOU3YyL)
- [Accessible UI Components For The Web](https://medium.com/p/39e727101a67)

## 44:04 Чехарда с цветовыми функциями

- [Switch all the color functions to be space-separated](https://github.com/w3c/csswg-drafts/commit/a54f8b2089d16eca696690fe7ffc3c11d4db9861)
- [CSS Function Syntaxes (color and otherwise)](http://www.xanthir.com/b4iW0)
- [Incomplete List of Mistakes in the Design of CSS](https://wiki.csswg.org/ideas/mistakes)

---

## 00:26 События

## 04:57 Инлайновое видео в iOS

## 08:09 ChakraCore на Mac и Linux

## 25:12 Модальные окна

**Вадим.** У нас на этой неделе много тем про доступность. Кто-то уже стонет, что мол сколько можно. Ну, до тех пор пока вы не поймёте, и я не буду видеть в интернете доступные сайты. Ладно, шучу. Просто действительно совпало много хороших статей на эту тему. И мне кажется, что это довольно важно.

Погранично с доступностью и вообще удобством был [хороший перевод](http://prgssr.ru/development/oformlenie-modalnyh-okon.html "Оформление модальных окон"). Крис Койер недавно на CSS-Tricks описал собственный опыт по работе с модальными окнами на страницах. Описал немного очевидные вещи, но которые на самом деле не очень-то очевидны рядовому разработчику: что модальные окна нужно фиксировать с `position: fixed`, что нужно делать их `max-width`, чтобы они не обрезались на экранах, и так далее.

Мой собственный опыт как пользователя интернета показывает, что регулярно я сталкиваюсь с тем, что я захожу на какой-нибудь сайт, он предлагает мне форму регистрации, и я не могу нормально проскроллить — оно зафиксировано и у `body` отключен какой-нибудь `overflow`, и в итоге оно ещё позиционируется c помощью JavaScript частенько. Получается очень плохо и очень страшно. И поскольку подобные вещи редко предусматриваются дизайнерами, ну то есть они вам рисуют модальное окно и говорят «поехали», — то вам приходится принимать очень много интерфейсных решений. Мне всегда казалось, что работа верстальщика довольно-таки интересная, потому что мы принимаем много интерфейсных решений.

Так вот Крис Койер советует, какие интерфейсные решения вам стоит принимать, когда вы работаете с модальными окнами. Он особо не притрагивается к теме доступности модальных окон, потому что там есть собственные какие-то нюансы, что фокус Таба должен быть пойман внутри этого модального окна, чтобы он не гулял по странице, что кнопку нужно всегда показывать видимой, чтобы из модального окна можно было выйти с клавиатуры. В общем, много есть нюансов. И если вы делаете модальные окна, или если у вас уже есть модальные окна, проверьте их по этому чеклисту, который предлагает Крис Койер, и возможно у вас найдётся повод что-то поправить в ваших модальных окнах.

**Лёша.** Я знаешь чего не обнаружил здесь. С одной стороны, это про доступность, но с другой стороны, мне всегда казалось, что это просто обязательная вещь. Я считаю, что нажимая клавишу Escape, ты должен закрывать то, что открывается. И для модальных окон это просто обязательная вещь в моём понимании. Мы привыкли в операционных системах, что всё, что у нас открывается, мы можем закрыть клавишей Escape, у нас есть всегда быстрая клавиша, которая нафиг всё закрывает, что всплыло.

И жалко, что в этой статье этого пункта нет, потому что я даже на «Базовом интенсиве» ребятам, когда рассказываю про JavaScript, я рассказываю, например, про этот элемент обязательно: ребята, мы закрыли по крестику, закрыли по вот этому оверлею кликом — это всё хорошо, но не забываем ещё закрыть по клавише Escape. Вроде такая банальная вещь, но делают её очень редко. А она ведь вносит такой положительный опыт работы с интерфейсами. То, что всплывает, оно чаще всего бесит, потому что чаще всего… Ну нет, не чаще всего конечно. Когда ты кликаешь на какой-то элемент, и у тебя всплывает формочка с вводом — это окей. Но иногда ведь модальные окна используют не так хорошо: в них открывают баннеры всплывающие и всё остальное. И вот в этом смысле их нужно срочно закрыть. Обязательно нужно, чтобы клавиша Escape работала.

**Вадим.** У меня с клавишей Escape связанна собственная боль. Кстати, escape — это убежать, escape — это выход. Поэтому не забывайте, что на этой клавише написано _то_, _что_ ваш пользователь скорее всего сделает, когда увидит ваше ненужное модальное окно.

Так вот личная боль связана с тем, что в браузерах Opera клавиша Escape выводит из полноэкранного режима. В какой-то момент это работало так и в Chrome, они потом это убрали. Но вот в Opera это поведение сохранилось. У меня частенько на ноутбуках маленькие экраны, потому что я их с собой вожу и так удобнее. И когда я пытаюсь закрыть модальное окно на сайте, а разработчики слушают Escape — всё происходит прекрасно, Escape закрывает окно. Но браузер ещё выходит из полноэкранного режима. А почему? Потому что вы, когда слушаете Escape, вы ловите его, выполняете ваш JavaScript, но не делаете `preventDefault()`. Браузер получает событие Escape и начинает обрабатывать его дополнительно. Вот это большая проблема, не только с Escape связанная. Частенько разработчики ещё слушают какие-то клавиши, Alt + [стрелочки] для навигации по странице и ещё что-нибудь такое, и не делают `preventDefault()`. Тогда это событие срабатывает и для вашего скрипта, и для браузера. А браузеры бывают разные, операционные системы бывают разные. Поэтому, если вы всё-таки сделали Escape — вы молодец, но не забудьте сделать `preventDefault()`, ведь Escape может использоваться самим браузером.

**Лёша.** Слушай, это прекрасный пример! У нас на курсе я всех заставляю делать `preventDefault()`, к слову. Но когда я рассказываю про это… То есть понятно, что мы в ссылке отменяем — действие по умолчанию, переход по ссылке — всё вроде как логично. Но в некоторых элементах, например в `<button>`, который ничего не делает, я тоже всегда ставлю `preventDefault()`, и меня спрашивают, почему. Вернее я у ребят спрашиваю, почему. И все гадают: как же, почему, что же может случиться. А я им всегда говорю: ну знаете, ребята, я параноик, я лучше лишний раз поставлю, в крайнем случае ничего не случится, вот прямо вообще ничего не случится; в другом случае, вы избежите всяких дурацких штук, потому что обычно JavaScript-разработчику должно быть пофиг на разметку. Откуда я знаю `<button>` там на самом деле или ссылка. Или сделал я скрипт, а прийдёт после меня какой-нибудь верстальщик и решит, что этот `<button>` нужно заменить на ссылку. И что, мой скрипт должен сломаться от этого. Нет конечно. И с Escape так же. Но вот этот пример про выход браузера из полноэкранного режима — это классный пример. Я теперь его буду рассказывать.

Ещё знаешь что мне понравилось в этой статье. Может быть я такой слоупок, но я до этой мысли как-то сам не дошёл, не знаю, не думал об этом. Про то, чтобы специальный класс делать для закрытия окна, и для открытия. По-моему гениальнейшая вещь. Я не знаю почему вообще такая простейшая вещь не вошла в мой мозг сама. Я совсем недавно как раз таки сталкивался с этой проблемой. Блин, я даже не додумался до этого, я не то чтобы долго думал, но тем не менее. Ровно та же проблема, которую он рассказывает. У нас блоку по умолчанию какой-то `display` задан, `display: block;` например. А сейчас часто из-за того, что есть флексы, может быть `flex`, а если это например список, то у него вообще отдельный есть `list-item`. И хорошо бы, когда вы `display: none;` делаете, ставить его обратно. Нужно вернуть же тот же самый `display`. И когда ты делаешь универсальный скрипт, такой toggler на всём сайте, например, с помощью data-атрибутов, то вам нужно как-то узнавать, про этот `display` и возвращать тот самый — и тут такие пляски с бубном получаются. А это же по-моему гениальнейшее решение: вы просто меняете их местами и у вас просто работает CSS. По моему это круто.

## 32:43 Сложные таблицы

**Вадим.** Ещё была одна статья про доступность, про доступность больших таблиц, даже не столько про доступность, сколько про то как их вообще сделать. Потому что мы как-бы получаем админки с огромными наборами данных и их как-то нужно показывать пользователям. И на десктопе мы более менее справлялись с этим, но когда приходят мобильные, нужно эти таблицы адаптировать. И на эту тему написано много всего интересного, и статей, и много разных фреймоворков, и библиотек, которые всё это реализуют. В общем много чего было сделано, но тут [высказался](https://medium.com/shopify-ux/lessons-from-building-mobile-friendly-accessible-data-tables-1e05c6924eaf#.90vszjhsr) Shopify — это такая система, которая делает удобные интернет-магазины. Допустим, A Book Apart, которая продаёт книги, использует её как интерфейс для продажи своих книг. Так вот Shopify (естественно у них там есть свои админки, где вы всё это анализируйте, есть какие-то большие данные) поделились своим опытом в серии постов про доступность как они сделали эти большие таблицы. Там есть очень много интересных советов, интересного опыта. Например, один из советов: не зацикливайтесь на прототипе. Когда вы поняли, как вы хотите, чтобы ваша таблица вела себя, сделав её на основе какой-то библиотечки, которую вы где-то откопали, не думайте, что вопрос решён, пойдём в продакшен, всё нормально. Подумайте о доступности вашего решения, подумайте насколько оно вообще оправдано, нужно ли вам грузить библиотеку и так далее. Shopify на своём опыте показал, что первый прототип, чтобы убедить дизайнеров и заказчиков как должен выглядеть интерфейс, был использован и успешно выброшен, а на его основе было написано компактное и доступное решение. В итоге оно оказалось гораздо лучше, чем тот самый прототип, потому что оно использовало таблицы для табличных данных (шок), а не дивы как это было в случае с прототипом. И более того проблему таблиц, которые становятся меньше на маленьких экранах, было решено сделать с помощью не одной таблицы, а — двух таблиц, и решение в итоге оказалось элегантным и интересным.

Вторая интересная мысль, которая озвучивается в этой статье, это то, что я уже говорил раньше — не предполагайте, если речь идёт о доступности, потому что когда мы пользуемся интерфейсами с помощью мышки и глаз, и в общем знакомых нам способов, мы не знаем как на самом деле будет работать средство доступности. В статье подробно рассматривается VoiceOver — это такой, встроенный в Mac и платформы Apple на iOS, помощник доступности, который читает ваши страницы. И в этот помощник, на самом деле, встроено много эвристики, которая пытается догадаться и помочь вам прочитывать ваши страницы доступным образом. Допустим есть момент, что VoiceOver не считает таблицу таблицей, если у рядов нет рамок — об этом есть отдельная статья от тех же авторов из Shopify. Но суть сводится к тому, что была ведь у нас эпоха, когда таблицы использовались для раскладок, и вот как наследие этой эпохи VoiceOver иногда считает вашу таблицу раскладочной. Поэтому, если вы просто сделали вашу таблицу таблицей, то вы уже молодцы. Но убедитесь, что VoiceOver правильно её понимает — может быть вам какие-то рамочки нужно добавить, чтобы всё было нормально.

То же самое с неожиданным моментом, что оказывается VoiceOver не считает дефис минусом. Приводится пример, у них в таблице было −90 $ и для того, чтобы сделать проще, чтобы пользователям было легче вводить и им тоже не париться, они использовали типографику для бедных, т.е. вместо нормального юникодного знака минуса, они взяли дефис, который совсем не предназначен для этого. И VoiceOver не читает `-90` как минус, потому что там дефис, и им в итоге пришлось использовать нормальный юникодный символ. В итоге, этот минус гораздо заметнее и понятнее тем, кто видит, и этот минус нормально прочитывается через VoiceOver. Поэтому оказывается нормальная типографика ещё и доступнее, чем типографика для бедных.

В общем, если вы делаете сложные таблицы, пробегитесь по этим рекомендациям, оцените опыт Shopify — они в общем-то серьёзные ребята. И эта не единственная статья в этой серии про доступность, очень рекомендую.

## 37:13 Формы и доступность

## 44:04 Чехарда с цветовыми функциями
