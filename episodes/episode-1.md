# Выпуск №1

Chrome 48, Firefox 44, Sass вместе с PostCSS, минимально необходимые шрифты, HTTPS, коты во фронтенде.

[Обсуждайте в Слаке](http://slack.web-standards.ru), в канале #​podcast.

00:50 Новинки браузеров

- [Chrome 48](https://youtu.be/TebeVxw95RI)
- [Firefox 44](http://tanalin.com/blog/2016/01/firefox-44/)

08:06 PhantomJS 2.1

- [PhantomJS 2.1](https://raw.githubusercontent.com/ariya/phantomjs/master/ChangeLog)

11:04 Переменные в CSS

- [Переменные как основа архитектуры CSS при работе с препроцессорами](http://prgssr.ru/development/peremennye-osnova-arhitektury-css.html)

21:17 Sass с PostCSS

- [Extending Sass with PostCSS](http://ashleynolan.co.uk/blog/extend-sass-with-postcss)

26:54 Загрузка шрифтов

- [Минимально необходимые шрифты](http://css-live.ru/articles/minimalno-neobxodimye-shrifty.html)

35:22 Спрайты

- [A Gulp-Based External SVG Symbol Sprite Icon System](https://una.im/svg-icons/)

39:49 Адаптивные картинки

- [Responsive Image Breakpoints Generator](http://www.responsivebreakpoints.com/)

41:50 HTTPS

- [Почему до сих пор повсеместно не используется HTTPS?](https://habrahabr.ru/post/275539/)

48:12 Парадоксы HTML и CSS

- [WTF, HTML & CSS?](http://wtfhtmlcss.com/)

52:05 Коты JS-фреймворки

- [Which cat is your JavaScript framework?](http://whichcatisyourjavascriptframework.com/)

---

**Вадим.** Привет, меня зовут Вадим, мы записываем пилотный выпуск подкаста Веб-стандарты и будем обсуждать новости и просто общаться с вами на темы фронтенда. Представлю наших гостей.

**Ольга.** Добрый день, меня зовут Ольга Алексашенко, я верстаю руками в течение 10 лет и в этом подкасте я буду представлять практическую сторону разработки.

**Алексей.** Привет, меня зовут Леша Симоненко, я большую часть времени общаюсь с сообществом и занимаюсь образованием в HTML Академии.

**Вадим.** Ок, да. А я Вадим, я работаю на браузерную компанию Опера, занимаюсь тоже образованием, организовываю конференции и прочее, прочее, прочее.

**Алексей.** Ну что, к темам?

## 00:50 Chrome 48

**Вадим.** Давайте начнем с самого такого дежурного, у нас очередные вещи обновили версию, мы обсуждали релиз, когда готовились к передаче, Chrome 48 и никто не смог вспомнить, что ж там нового. Действительно, вот эта вот версионность новая, которая появилась, не знаю, в Chrome'е, в опере, в Firefox'е и во многих других, она, конечно, немножко до сих пор смущает людей, все такие "Ой, Firefox 44, я помню 10ка выходила, и что там нового, по сравнению с 43им Firefox'ом?", еще что-то такое...

**Алексей.** Но знаешь кстати, с другой стороны я бы очень хотел, чтобы то же самое произошло со всеми браузерами, и например вот от Safary хочется такого ожидать, и тогда было бы... Тогда пофиг, что они называются 48, 49, 67, главное - что он просто релизится частои поддерживает больше штук быстрее.

**Вадим.** У Safary сейчас начинает такое происходить, они раньше только в мажорных версиях добавляли или исправляли что-то новое, меняли, ну там, Webkit Web View там, вернее UI Webkit и, собственно, встроенный браузер тоже обновлялся мажорными версиями, а сейчас в минорных версиях уже начинают появляться какие-то изменения, соответственно, сейчас уже разработчикам доступны беты MacOS следующей версии, и там следующей версии iOS и там уже серьезные обновления, типа там поддержка <picture> там всякие...

**Алексей.** Да, да, да... Там переменные, например CSS будут, это Safari 9.1 будет, вот ждем его

## 02:30 Firefox 44

**Вадим.** Например, в упомянутом Firefox'е 44 большая вещь, которую наконец-то вынули из флагов, это сервис-воркеры и пуш-уведомления, соответственно, вещь более важная, наверное, для мобильных браузеров, Firefox на мобильных не особо силен, но у них все-таки есть версия Firefox для андроида с собственным движком, но поддержка, альтернативная поддержка какой-то спецификации и технологий - это всегда очень важный шаг, до этого сервис-воркеры работали только в движке Chromium, соответственно Chrome, Opera, Yandex browser и так далее. Сейчас у нас появилась альтернативная реализация, то же самое было с pointer-events, то же самое было с элементом <picture> и так далее. То есть, как бы альтернативная реализация говорит разработчикам: типа все, это в серьез, давайте использовать, вот точно давайте использовать. И самые простые примеры, которые сейчас появляются с поддержкой сервис воркеров - это оффлайновые страницы, опять же, мало кто понимает зачем это делается. У вас есть какой-нибудь опыт, собственно, вы хоть раз трогали сервис-воркеры и вообще, понимаете как это работает, что это делается?

**Ольга.** Нет, мне не приходилось работать с сервис-воркерами, потому что я все-таки больше верстальщик, чем JS программист, но выход новых фич в файрфоксе - это очень хорошо, потому что сейчас вот для меня файрфокс - это такой новый ИЕ: везде все хорошо - в файрфоксе обязательно что-нибудь не работает или что-нибудь поехало, в общем - удивительный браузер, раньше я очень-очень его любила и пользовалась только им, но вот уже года два - увы... Так что я рада выходу новых фич.

**Алексей.** Я самими сервис-воркерами не пользовался, но я пользовался предыдущей реинкарнацией - это Аппликейшн кэшем, это было очень давно... Ну как, три года, наверное, да?

**Вадим.** Это очень давно, три года во фронтенде, я уж не помню...

**Алексей.** Ну да, я тогда делал какую-то ммм... Такой, знаешь... Калькулятор подсчета стоимости разработки сайтов, такой развесистый весь, со всякими разными шутками и хотелось чтобы он работал всегда и... Есть интернет, нет интернета и так далее, и Application Cache это, конечно, все тогда очень радовались: "круто, круто, и правда - в оффлайне! смотри, я выключаю интернет, выключаю Wi-fi, а оно работает", это здорово. Но проблем мы огребли, конечно, огромное количество: это и невозможность что-то обновить, и... Да вообще, работа с Application Cache'ем была ужасной... Кстати, вот я заметил, что в 44ом Firefox'е Application Cache-то еще поддерживается, но уже выводит предупреждение о том, что это устаревший метод и его, наверное, уже использовать нельзя. Но это ладно, это о старом, а вот знаешь, о сервис-воркерах: я вот пока себе вижу использование его не совсем по прямому назначению, то есть не для оффлайновых страниц, а скорее для кэша, и вот эта идея мне понравилась. 

**Вадим.** Ну, там на самом деле он настолько низкоуровневый сервис-воркер, что прямого назначения у него, как такового, нет. У него есть... Это просто апи, которое позволяет делать... Решать ваши задачи, а одна из задач - которую очень просто сделать - сделать так, чтобы ваш сайт "застревал" в браузере, даже когда сайт, собственно, закрыт, и имел возможность показать что-нибудь когда интернета нет. Не просто голую страницу с динозавриком, или какой у вас там браузер, а именно вот что-то полезное, там на сайте Guardian они кроссворд сделали, мы с коллегами на Dev.Опере думаем сделать архив последних, там, пяти статей, чтобы можно было даже в оффлайне почитать их со всеми ресурсами и так далее. Естественно, нужно думать о кэше, особенно на мобильных устройствах, чтобы как бы не занять слишком много, но, опять же, без картин... Можно картинки не класть, можно с помощью сервис-воркеров подменять картинки на какие-нибудь заглушки, прямо на лету, прямо вот именно их класть в кэш, то есть штука слишком мощная, чтобы не знать - не пользоваться. Опять же, дело скорее не для верстальщиков, но знать... Переломить у себя в голове идею того, что оффлайн - это тоже место, где мы можем что-то делать - это очень, очень, очень интересно, очень интересная вещь, которой точно стоит заниматься.

**Алексей.** Ну, кстати это не совсем всем понятно, потому что я вот... На этой неделе были тоже статьи про работу сервис-воркеров, вот как раз то, что ты рассказал про оффлайновую страницу, да, на веб-стандартах, и там были очень показательные комментарии ВКонтакте, что... "А вообще нафига это надо?"

**Ольга.** Ну, очень хороший пример, например, это почта, вот... У тебя нет интернета, но ты хочешь в Google Mail посмотреть свой архив писем - это очень, очень нужная фича и мне ее очень не хватает.

**Вадим.** Ну, насколько я понимаю, до сих пор ни Google Inbox, ни Google Mail не могут показать тебе список писем, если ты открыл их... Ммм... Если у тебя нет интернета, то есть даже Google, который изо всех сил, там, продвигает использование оффлайн сервис-воркеров, кэша и так далее, даже они еще не перевели свои крупные приложения на полноценную работу.

## 08:06 PhantomJS 2.1

**Алексей.** Ну что, я кстати... На этой неделе еще знаете что вышло? PhantomJS! Наконец-то разрадился версией, какая она там... 2.1, да. Это не совсем браузер, но что-то близкое, да, это оторванный движок от браузера и, честно говоря, у нас для Phantom'a альтернативы нет... Вы пользуетесь же Phantom'ом?

**Вадим.** Ну, я пользуюсь Phantom'ом для тестирования, то есть я прогоняю какие-то функциональные тесты для своих, там, проектов, для парочки, соответственно, пользуюсь в автоматическом режиме, естественно.

**Алексей.** А мы вот Phantom-то очень сильно используем, и я, честно говоря, ну, вот у нас нет альтернативы и я с радостью принял бы, если бы какой-нибудь ммм... Ребята из Google'a для Blink'a выпустили что-то похожее, или да даже пускай Edge выпустит, ой, Microsoft выпустит движок свой в таком виде, потому что вот эта безальтернативность, она, конечно, не очень хороша и я поясню почему. Дело в том, что год назад зарелизилась версия 2.0, ровно двадцать третьего января 2015 года и сейчас версия 2.1, минорная версия, зарелизилась спустя год, при этом при релизе 2.0 у них было огромное количество багов, которые никуда не девались течение всего года. Это, на самом деле, очень печально, ну, вот если вы прям используете его постоянно.

**Вадим.** Ну то есть, одно дело - когда тебе всего лишь нужно прогнать тест какой-то там джаваскриптик, особенно какой-нибудь  юнит-тест простой, там, джаваскриптовый выполнить - это понятно, но когда тебе нужно отрендерить картинку, чтобы оно работало еще и так же, как работает в других браузерах, в живых браузерах, и так далее, и так далее - это, конечно, большая проблема. А не пробовали ли вы использовать Electron для этого? Есть же какой-то... Есть, дай бог памяти как он называется, то ли Nightmare называется, то ли еще как-то...

**Алексей.** Nightmare - это да, это тестовый фреймворк

**Вадим.** Да, да, это тестовый фреймворк, вроде Phantom'a, который использует Electron, на котором, собственно, написан Atom, там, Slack написани так далее, такой, грубо говоря, обертка вокруг Chromium'a, который позволяет делать... Позволяет через API обращаться тоже к браузеру и запускать его "безголовым"

**Алексей.** Угумс, потому что я что-то раньше его видел, но тогда он особо ничем... Ну, то есть каким-то APIем сверху отличался, конечно, но это был тот же самыый Phantom, как мне кажется, поэтому мы его никогда и не использовали, но если он работает с Electron'ом, кстати, это хорошая идея, и я думаю мы посмотрим. Ну, хорошо, я думаю мы так хорошо обсудили релизы, которые вышли на этой неделе, давайте может быть тогда обсудим статьи по препроцессорам? 

## 11:04 Переменные как основа архитектуры CSS

**Алексей.** На этой неделе были хорошие статьи, вот например был перевод, да, кажется на... Где там... На Progressor'е. Дело в том, что я считаю, что то, как используют препроцессоры это не очень хорошо, ну потому что препроцессоры - это такая, это штука, которая была введена в CSS, то есть она была добавлена для людей, которые пишут CSS, чаще всего они не программисты, но при этом препроцессоры - это такой внос какого-то немножко "мира программирования" в CSS, и основная проблема, как мне кажется, с препроцессорами в том, что добавили некую... Некое программирование в CSS для людей, которые с программированием вообще никак не связаны и из-за этого почти все проблемы, то есть... Ммм... Ну например, знаешь, какие основные проблемы? Вот любят... есть в каждом препроцессоре такая штука, как... Они делают кусочек слова и через амперсанд ставят слово-родитель, ну там название класса, например, там, ну я не знаю ".page", а там следующий класс - это амперсанд...

**Вадим.** (перебивает) - к-к-к-конструируют селектор

**Алексей.** (продолжает) - да, и это я считаю что ужасно, ну то есть когда ты работаешь в одном проекте - это, наверное, замечательно, ты такой бог этого проекта и ты все знаешь, но как только ты отдаешь его другому человеку... Вот он нашел этот класс у себя там, я не знаю, ну где-то в верстке, да, и пытается - ну, у тебя конечно же CSS громадный, да - и пытается его найти... Ну как мы ищем - поиском наверное, да? - в редакторе... И эту штуку найти невозможно...

**Вадим.** Нет, ну если мы используем компонентный подход, и если мы бьем... У нас один модуль на один файл, соответственно, мы все быстро сможем найти!

**Алексей.** Ну подожди, это е... То есть... Это если... В идеале, когда у тебя совсем маленький файл, очень маленькие модули, да, но чаще в практике встречается... Ну, вот я просто... Мы, когда обучаем ребят и видим, как наши, там, наставники, например, пишут код и предлагают писать код, это вот все, вот, в твою красивую красивую теорию... Разбивается, на практике все происходит по-другому, там просто ужас происходит, ты ничего найти не можешь. Да, там бьется все на файлы, но эти файлы тоже большие, в них тоже ничего не найти, и... А главное - в чем преимущество-то? В том, что ты быстрее набираешь? Быстрее набираешь текст?

**Вадим.** Аааавввффф... Можно переименовывать блоки быстрее таким образом, не ковыряясь, можно скопировать внутренности одного блока в другой блок без переименования всех селекторов, и так далее... То есть, плюсы есть, то есть я мо... Я иногда легко копирую внутренности какого-то блока, там, с медиа-выражениями с какими-то там миксинами, еще с чем-то, в другой блок, чтобы как-бы ни... Конечно, стоит абстрагировать такие вещи, но иногда удобнее и проще скопировать, и тебе не нужно переименовывать вещи, ну то есть код более реиспользуемый становится из-за этого, как минимум для меня.

**Алексей.** Ну, а Оля, кстати... Оль, ты используешь препроцессоры?

**Ольга.** Да, использую.

**Алексей.** А ты там прям все-все используешь?

**Ольга.** Ну, я не уверена, что я знаю о них все, потому что в моей голове нет справочника, но пользуюсь достаточно широким набором возможностей: миксинами, амперсандами - но немножко не так, как вы тут осудили - вот, переменными, всякими калькуляциями, экстендами, в общем, это очень удобно, на мой вкус.

**Алексей.** Ну, мне, знаешь, еще кажется почему это не очень хорошо - я вообще считаю, что препроцессоры, в целом, это хорошо, ну потому что это дает толчок развитию самой спецификации CSS, потому что многое она заимствует... Но то, как используют, вот, еще раз повторюсь, это не очень хорошо. Мне кажется, самое хорошее, что есть в препроцессорах и что следует использовать всегда, это конечно импорты, да, разделение на много файлов это замечательная штука, это конечно... Ну, вложенность, когда у тебя нет никаких холиваров на проектах по поводу вложенности... Знаешь, есть люди, которые неистово за то, чтобы вложенности вообще ни... каскада вообще никакого не было. Если таких нет людей на проекте, то, как бы, тут тоже все удобно. В какой-то мере это вычисления, хотя сейчас calc уже поддерживается, по-моему, достаточно хорошо... Ммм... И, в какой-то мере, переменные - но вот с переменными, как в по большей мере статья вот эта на прогрессоре, она о переменных, и я тут с автором немного не согласен, потому что автор выступает за то, чтобы у тебя все переменные были в одном файле. То есть, типа такой глобальный файл, со всеми переменными... он, конечно, говорит: "Не надо создавать много переменных, там, делайте по-уму", но это тоже не очень хороший подход, потому что это больше похоже не на переменные, ну если мы берем, там, какие-то классические языки программирования, это не переменные, а константы. Вот тогда да, это похоже, когда мы выносим их в какой-то конфиг и они у нас там, типа, ну, как, такие константы, да, в конфиге, а переменные - это все-таки штука локального назначения, то есть у тебя какой-то, ну я не знаю, модуль, да, и ему, для его работы, было бы удобнее иметь какую-то переменную. Вот в этом смысле - это удобно. Вот, например, у нас слайдер есть какой-нибудь, мы его описываем и он там... Он у нас не динамический, а мы его меняем... Количество слайдов меняем в CSS'е, и тут, конечно, удобно через переменную задать этих количество слайдов и там делить ширину, высоту, ну, все что нужно, в зависимости от этой переменной. Мы заходим, у нас количество слайдов поменялось, мы меняем эту переменную - все замечательно, но зачем задавать - если вы, конечно, не пишете фреймворк - но зачем задавать цвета, размеры шрифтов в переменные - вот для меня это загадка.

**Ольга.** Ну, это как раз использование переменных в качестве констант. Ты очень правильно сказал про файл с константами, это действительно очень полезно, вот, например, я пользуюсь такими вещами для создания цветовых схем. У меня есть приложение, в котором есть дневная схема и ночная схема, и я все цвета храню в переменных, это очень-очень удобно, а так же там хранятся всякие константы типа семейств шрифтов... Ну, удобно просто не прописывать огромную вот эту вот строчку десять тысяч раз со всем перечислением шрифтов: например, тебе тут нужен Sans, тебе тут нужно Serif, Serif Caption... Удобно пользоваться глобальными переменнами. То же самое про line-height и... Ну, в общем, не знаю, по-моему это очень удобно.

**Вадим.** Ну, лично у меня тоже на всех проектах, которые я делаю, у меня есть файл defaults, scss в моем случае, где я храню базовые вещи, включая маленькие функции, которые, там, я использую, всякие миксины. Но он обычно, там, не больше сотни строк, включая комментарии и прочее, и прочее. Это действительно... Я думаю, проблема... Твой праведный гнев скорее относится к тому, что это действительно константы, а не переменные как таковые, так что, наверное, стоит... Не думаю, что на уровне языка и препроцессоров стоит разделять прям константы от переменных, но поговорить с разработчиком и понять разработчикам, что такие вещи стоит разделять - да, пожалуй, стоит, потому что есть пример совершенно из другой области: я свой gulp-файл в какой-то момент начал разделять на отдельные вещи, складывать в папочку, там, таски и так далее, и в какой-то момент я понял, что... И в руководстве, которое помогало мне это делать, было написано, что "выносите все пути в config.js и используйте пути". И я, конечно, все, как молодец, пошел по инструкции все вынес в конфиг, и я понял, что некоторые вещи у меня упомянуты в конфиге и использованы один раз, то есть такая переменная, которая используется один раз - это не переменная, как мы все знаем, это так, ну на будущее скорее. Поэтому, я настолько "законфигал" весь свой gulp, разбитый по файлам, что я... Мне стало не удобно в нем ориентироваться. Такой же ерунды можно наделать в своем CSS'е, так что да.

**Алексей.** Ну да, тут хочется какой-то, знаешь... Видимости всего, то есть все-таки с этим... С этой штукой должны работать, а не для кого-то она должна быть удобной, а чтобы с ней работать - все должны быть в контексте, но если человек приходит в проект - это очень тяжело.

**Ольга.** Ну смотрите, здесь есть плюс еще и в том, что подобные возможности условного языка, да, они приучают людей к абстрагированию. Для верстальщиков это очень важно как переход к модульности, переход к абстрагированию каких-то вещей - это все очень сильно облегчает код и это полезно.

**Алексей.** Ну, знаешь, я не уверен в этом, потому что... Мне кажется, с препроцессорами, и вот с любовью всех перетаскивать в конкретные простые проекты подходов написания фреймворков - это все слишком добавляет большую абстракцию в конкретный проект. Вот в конкретном проекте должен быть минимум абстракций, он же конкретный, вот у тебя дизайн и он должен быть таким, ты же не фреймворк пишешь... И когда он, ну вот, в моем понимании, если он конкретный - то вот вся эта абстракция - она нафиг никому не нужна, это скорее ты просто взял ну... Почему так происходит? потому что ни у кого нет в голове мысли о том, как правильно. Где посмотреть, как правильно? Давайте возьмем bootstrap, или там, я не знаю, еще foundation, еще какой-нибудь фреймворк и посмотрим. Но у них-то задача абсолютно другая.

## 21:17 Расширяем Sass с помощью PostCSS

**Вадим.** Давайте тогда еще буквально последнюю вещь про препроцессоры и прочее, просто чтобы сделать этот выпуск моднее: кто-нибудь PostCSS использует у себя в продакшене как таковой? Оля?

**Ольга.** Да, мы пользуемся PostCSS'ом и это все мы заговорили к слову о статье "Extending SASS with PostCSS", здесь у нас автор как раз ему, видимо, задавали много раз вопрос "зачем он использует одновременно и SASS и PostCSS и почему это надо", потому что это все дублирует, якобы, друг друга, но нет, у PostCSS'a есть прекрасное свойство... Прекрасные модули, которые могут уже ваш готовый код сделать еще лучше, например, инлайнеры всякие, минификаторы, конечно, автопрефиксер - если кто-то еще не вынес автопрефиксер в модуль PostCSS'а, то уже очень пора сделать - всякая SVG-оптимизация, в общем очень-очень полезная вещь и в этой статье, в частности, есть много ссылок как можно улучшить свою разработку на SASS и SCSS при помощи PostCSS.

**Вадим.** Мой личный опыт показывает, что, как бы, автопрефиксер, типа, must have, они заставили меня перейти на PostCSS плагины - привет, Андрей! - вместо того, чтобы использовать gulp- или grunt- плагины с автопрефиксером непосредственно, но это ладно, имеют право, видимо. Но вот из такого, из полезного, мне больше всего нравится SVG-инлайнеры, которые позволяют... Которые знают, как нужно вставить SVG в виде... Прямо... Прямо в исходник, вернее, прямо в CSS файл не конвертируя в base64, а вот экранируя всякие кавычечки, там угловые скобки и так далее, чтобы один файл подгрузился и весь SVG у тебя на месте, а не по запросу на каждый - вот один из самых полезных плагинов, которые как-бы существуют лично для меня.

**Алексей.** Я тут вам, наверное, буду ортагонален, но вот у нас сейчас последнее время новые страницы в академии, они верстают полностью на PostCSS, то есть там вообще нет никакого препроцессора, это, наверное, погреет душу Андрею, но вот нам это понравилось и мы вообще не чувствуем никак обделенными препроцессором, потому что все необходимое, что мы хотим, оно есть в PostCSS.

**Вадим.** А ты можешь перечислить фичи, которые вы используете... Те необходимые фичи, которые вы используете из препроцессоров? Которые вы набрали с помощью PostCSS плагинов?

**Алексей.** Ну, мы используем переменные, конечно, частично...

**Вадим.** То есть вот такие, с долларом, да? CSSные переменные?

**Алексей.** Нет, мы... Знаешь, когда я ставил эту задачу, вообще... Моя любовь в этих всех технологиях в том, что я хочу, чтобы было все в итоге по спецификации, вот очень хочу, вот мне поэтому все вот это там, например, Babel.js для js'a нравится, вот мне нравятся инструменты, которые делают в итоге то, к чему придет, то есть мы уже пишем и учимся так, как скоро будут все по-умолчанию.

**Вадим.** Ну то есть вы просто подключили PostCSS... CSSNext, точнее, в виде плагина, да?

**Алексей.** Ну, там, знаешь, у нас, конечно, не все так просто, там CSSNext не полностью, то есть там некоторые вещи вырезаны из CSSNext'a, а некоторые еще добавлены вот которые вещи, которых нету просто в CSS'е, но которых вот нашему верстальщику очень-очень-очень понадобилось: это, например, вот эти вот вложенные с амперсандами верхними уровнями там, и так далее.

**Вадим.** Ок, ну то есть вы набрали нужный комплект и, в общем-то, рады и багов особо не было, да?

**Алексей.** Нет, вообще не видим никаких багов... Нет, ну конечно когда мы весь этот процесс собирали, там багов было огромное количество, потому что в PostCSS'е есть некая, знаешь, дурацкая штука, что там нужен определенный порядок всех плагинов, причем иначе они будут как-то криво работать или не работать, там нужно, если вы используете какой-то набор плагинов, типа CSSNext'a и так далее, но используете не только его, а еще ряд плагинов, которые, знаешь, нужно воткнуть где-то в середину...

**Вадим.** Угумс...

**Алексей.** ...вот это тоже рождает проблемы и приходится там из CSSNext'a выключать какие-то плагины, брать их отдельно, кусками, подключать перед... Ну, в общем, конечно вот настроить себе окружение для работы PostCSS'a - это то еще дело, но это вполне возможно и мы это сделали, ну, наверное, закончили вот это вот конфигурирование полгода назад и с тех пор вообще эту штуку не трогаем и она нас полностью устраивает.

**Вадим.** То есть после того, как намучались - мучаться перестали?

**Алексей.** Да. Ну, как-то так, да.

## 26:54 Минимально необходимые шрифты Зака Лезермана

**Вадим.** Ок. Ладно, я предлагаю перейти к техникам, к... У нас есть несколько статей на тему, там, шрифтов, SVG, там, и элемента picture и прочее обсудить, что нового и интересного, какие техники предлагают. Вот я слышал, Оля, что тебе понравилась статья про минимально необходимые шрифты Зака Лизермана (Zach Leatherman)?

**Ольга.** Да, это довольно интересная и полезная статья, во-первых он описывает все четыре основных способа подключения веб-шрифтов с их недостатками, мы лично сейчас используем на своем главном проекте второй способ - это встраивание шрифтов с помощью data URI и подгрузки таблицы стилей асинхронно, но у него есть такой минус: это техника "засовывать шрифты в local storage", и, соответственно, проверять, нет ли шрифтов... Ну, браузер уже потом проверяет, нет ли шрифтов в local storag'e, и если вдруг вам в local storage попал какой-то побитый шрифт, вызывает много, в общем, проблем у конечного пользователя. Собственно, способ, который описан в этой статье, он предполагает уменьшение файла шрифта. Ну, во-первых его предлагается сохранить в формате woff2 и потом сконвертить в base64, насколько я поняла... В общем, суть этого метода в том, чтобы взять из нужного шрифта самые используемые глифы и на первом этапе загрузить только их, чтобы страница показалась как можно быстрее при минимальной загрузке, а потом уже в процессе догрузить все остальное. Шрифт мелькнет при этом, ну... Уже, типа, будет покрасивше все.

**Алексей.** Наверное, стоит сказать и о других способах, потому что их всего было пять, ты сказала про второй и самый последний, пятый. Первый способ - это ничего не делать, это когда мы просто используем директиву "@font-face" и ждем милости от браузера, чтобы он все сам сделал, и это, по мнению автора, считается анти-паттерном уже, то есть это, наверное, из всех возможных способов самый худший способ. Третий способ - это когда мы работаем с "динамическим классом", то есть у нас изначально шрифт не используется, мы подгружаем с помощью какой-нибудь js API для подгрузки шрифта, или, там, встроенного в браузер, или отдельной библиотекой подгружаем этот шрифт и только когда мы уверены, что он подгрузился, мы добавляем класс к body, который добавляет этот шрифт в CSS. И четвертый принцип - это когда мы вот эту же технику делим просто на несколько маленьких шрифтов, то есть в предыдущей технике мы грузили все семейство шрифтов, то есть и жирный, и, там, наклонный, и так далее, шрифт, а в четвертой технике нам предлагают разделить шрифты на каждый кусочек и загружать отдельно каждый, каждое начертание с помощью JS и добавлять соответствующий класс для "<body>" и... Ну вот как по-вашему, Вадим, тебе какой способ нравится?

**Вадим.** Я делал в конце года прошлого редизайн WSD (Web Standarts Days) конференции, и там я использовал следующий подход: прямое начертания я "инлайнил" в основной CSS, там используется, по-моему, "Roboto" шрифт, там, естественно, и латиница, и кириллица, но получается не так тяжело в формате ".woff" - не ".woff2", потому что ".woff2" менее совместимый, а в формате ".woff" - все равно, как бы, получилось, там, по-моему, порядка 60-ти килобайтов, но это зато в одном файле все проскакивает... Это прямое начертание "инлайнится", а остальные начертания в "голове" на странице подгружаются уже асинхронно, тоже в виде CSS файлов, то есть вот подобный способ, он как бы не является в чистом виде ни одним из описанных, и, наверное, стоило бы добавить в это дело еще local storage и прочее, прочее, прочее, но вот подобный способ - самый простой, типа прямое начертание, а потом - асинхронно все остальные, по-моему, лучше всего подходит, ну, скажем так, для такой, базовой, оптимизации подгрузки шрифтов.

**Алексей.** Если спросить меня, как мы использовали шрифт, то мы делали примерно то же самое, что делала Оля у себя на проекте, мы запихивали в CSS-файл base64-шрифт и этот CSS-файл подгружали JSом, асинхронно, и, когда он подгружался, кидали его в local storage, но, честно вам скажу, это не очень хороший способ, потому что, ну, доходит до таких простых вещей, что local storage, ну, если у вас нормальный шрифт, с нормальным количеством килобайт, у вас просто local storage может зависнуть и крашнуть ваш браузер, легко. Он просто не может открыть такое количество текста, не знаю почему, вот даже сегодня я ставил Firefox 44-ый, который новый, пытался открыть его - так же самая история, все падает. Техника хорошая, быстро работает, но вот за счет того, что идет работа с local storage'ем, это не очень прикольно, ну и плюс нужно помнить, что такое количество информации в local storag'e, и когда вы в следующий раз достаете ее из lcoal storage'a, она очень сильно, во-первых, на мобильных очень потребляет вашу батарейку, а во-вторых очень сильно задерживает ваш процессор, поэтому это не самая хорошая техника, и вот сейчас, вот, буквально, на прошлой неделе, мы переделали все на вот этот способ с подгрузкой шрифта через js API, то есть у нас этот "@font-face on load" - хотелось бы использовать встроенный в браузере API, но там поддержка не очень хорошая - мы сейчас подгружаем шрифты через js, причем, каждое начертание - отдельным потоком, что позволяет браузеру, там, например, в четыре потока их грузить одновременно...

**Вадим.** А вы кодируете файл шрифта во что-нибудь, или он как есть?

**Алексей.** ...нет, шрифт лежит как есть, это ".woff" и ".woff2" форматы, в CSSе из "<body>" выносится этот шрифт, у нас "Muller" используется, он выносится там, а "Arial" только... И в классе, там, ".muller" будет на "<body>", меняется "font-family", и, когда мы в js'е подгружаем все начертания, ну там, promise'ом, да, все четыре начертания к нам приходят, мы просто добавляем этот класс. Ну а дальше есть хитрая техника, это когда мы первый раз их загрузили, мы кидаем в session storage какую-нибудь переменную, что шрифты были первый раз загружены у пользователя, и второй раз, когда он заходит, мы уже вообще ничего не трогаем, мы смотрим, что эта переменная у нас есть, значит браузер эти шрифты трогал, значит, если ваш сервер правильно настроен, они закэшированы браузером, и мы просто в этот момент добавляем класс в "<body>" и все происходит очень быстро.

**Вадим.** Возвращаясь немножко к первой технике, которую Зак называет анти-паттерном, что не стоит сейчас браузеру просто отдавать шрифт с помощью font-face'a, вообще все шрифты, что у вас есть на проекте, чтобы он их кэшировал и т.д., на мой взгляд, так должно быть: подключаете - и оно работает, так должны работать все технологии в браузерах, а то, что мы сейчас делаем - мы сейчас пытаемся станцевать с бубном, чтобы оно заработало лучше, но на самом деле лучше оно должно работать с помощью API браузерных, с помощью просто встроенной браузерной магии.

**Алексей.** Ну да. В общем, ждем "font-display"... Мне тоже кажется, что этим должны заниматься браузеры, и тем более... Вообще странно, что изначально, когда добавили шрифты, никто не подумал про это...

**Вадим.** А их никто не использовал, потому что они слишком тяжелые были

**Алексей.** Ну да, ну по ходу, как обычно и получается, то есть практика применения показала, что все проблемы... И вот оно решение...

## 35:22 Система символьных спрайтов Юны Краветц

**Вадим.** Ну, и немножечко еще про хаки, у нас все еще нет нормальной системы, пожалуй, использования иконок в браузерах, мы все еще пытаемся выяснить нормальный способ, мне кажется, что еще куча людей сидит на иконочных шрифтах. Какой у вас опыт в этом смысле?

**Алексей.** Иконочными шрифтами мы почти сразу перестали пользоваться, как только, ну вот, именно, знаешь, старым способом, почти сразу же, как только поняли все его проблемы, то что не загружается, загружается криво, Opera Mini их вообще вырезает, и все остальное, с этим связанное. [35:58]
