# Выпуск №25

Atom, доступность, загрузка шрифтов, промисы, векторные эффекты, Антон Виноградов про код, дизайн и Protein.

[Обсуждайте в Слаке](http://slack.web-standards.ru), в канале #​podcast.

## 00:13 События

- [IT Global Meetup](http://piter-united.ru/itgm8/itgm.html)
- [Frontend Union Conf](http://frontend-union.co/), промо-код WelcomeWST со скидкой 15%
- [MoscowJS №32](https://events.yandex.ru/events/yagosti/28-july-2016/) в Яндексе
- FrontendFellows в Казахстане: [29 июля Астана](https://frontendfellows.timepad.ru/event/328848/), [30 июля Алматы](https://frontendfellows.timepad.ru/event/349319/)
- [WSD осенью](https://wsd.events/#calendar), заявки на wst@web-standards.ru

## 03:03 Плагины для Atom

- [Atom treasures, a list of Atom plugins I can’t live without](https://medium.com/p/82a64ac391c)
- [HyperTerm](https://hyperterm.org/), терминал на Electron и веб-технологиях
- [Atom Minimap](https://atom.io/packages/minimap)
- [Atom Pair](https://atom.io/packages/atom-pair)

## 10:44 Доступность

- [ChromeLens](http://chromelens.xyz/)
- [Accessibility Developer Tools](https://chrome.google.com/webstore/detail/accessibility-developer-t/fpkknkljclfencbdbgkenhalefipecmb?hl=en)
- [A11y Command-line Tools](https://addyosmani.com/a11y/)

## 14:26 Загрузка шрифтов

- [A Comprehensive Guide to Font Loading Strategies](https://www.zachleat.com/web/comprehensive-webfonts/)
- [CSS Font Rendering Controls](https://tabatkins.github.io/specs/css-font-display/)
- [Can I use: font-display support](https://github.com/Fyrd/caniuse/issues/2001)

## 19:59 Введение в промисы

- [JavaScript Promises 101](https://bitsofco.de/javascript-promises-101/)

## 26:16 Векторные эффекты

- [SVG Vector Effects](http://callmenick.com/post/svg-vector-effects)

## 29:10 Кто такой Антон Виноградов?

- [Антон Виноградов](https://www.facebook.com/awinogradov)
- [Данила Ковчий](https://events.yandex.ru/lib/people/403/) и [Антон Шеин](https://events.yandex.ru/lib/people/3421690/)
- [Роман Шамин](https://github.com/romashamin?tab=repositories) из «Злых марсиан» и его плагины для Sketch
- [Design Prosmotr](http://designprosmotr.ru/)
- [О чём смеются верстальщики](https://www.youtube.com/watch?v=lW4uzJp6uIg)
- [Школа дизайна Яндекса](https://www.youtube.com/playlist?list=PLLkvpHo_HuBMU_fM4v-VS5VbUi9QuKyDR)

## 39:39 Инструменты для дизайнеров

- [Next-Generation RWD Tools: Webflow, Edge Reflow, Macaw](https://www.smashingmagazine.com/2014/05/next-generation-responsive-web-design-tools-webflow-edge-reflow-macaw/)
- [Protein](http://theprotein.io/)
- [Protein Dynamics for Sketch](https://github.com/theprotein/dynamics-sketch)
- [Framer](http://framerjs.com/)

## 58:13 Расшифровки подкаста

- [Выпуск №24](https://github.com/web-standards-ru/podcast/blob/master/episodes/episode-24.md)

---

**Вадим.** Привет, с вами 25-й выпуск подкаста «Веб-стандарты» и его постоянные ведущие: Алексей Симоненко из HTML Академии.

**Лёша.** И Вадим Макеев из Оперы.

** Вадим.** И сегодня у нас в гостях Антон Виноградов из Яндекса.

**Антон.** Привет!

## 00:13 События

**Вадим.** В прошлом выпуске я сетовал, что как-то маловато событий, и тут поднасыпало. Неожиданно появился [IT Global Meetup](http://piter-united.ru/itgm8/itgm.html) в Питере. Это такая штука, инициатива, в которой пытаются собрать все городские события, и в одном месте. Всякие там Ruby, фронтенд, ну, в общем, кто только может собраться, приходят в одно место, им там отдают свои уголки, и они там встречаются с сообществами. Ну и, в общем-то, интересный опыт и хороший старт, наверное, для сообщества. Мы с PiterCSS закрыли сезон, поэтому мы там особо не будем. Но нас с Лёшей позвали выступить на круглом столе в рамках PiterJS. PiterJS существует, как выяснилось, и он иногда собирается. В общем, вечером 23 июля увидите нас на круглом столе, на «IT Global Meetup».

И новости про [Frontend Union Conf](http://frontend-union.co/). Они всё ещё собираются провести классную конференцию 27-го августа в Вильнюсе. Но ещё ребята дали нам промо-код, который сэкономит вам целых 15 евро. Билет стоит 95 евро, а с нашим промо-кодом он будет стоить 80 евро. Поэтому WelcomeWST, мы промо-код в (неразб., TODO) конечно укажем, поэтому копируйте, покупайте билет и увидимся в Вильнюсе.

А ещё анонсировали [MoscowJS №32](https://events.yandex.ru/events/yagosti/28-july-2016/) 28 июля в Яндексе. Я сейчас сижу думаю, съездить или не съездить, там довольно интересные темы получаются. Я уже был на последних двух MoscowJS, может быть и не прерывать традицию.

Вот, а FrontendFellows, наконец-то, едут в Казахстан обещанный. Они едут не только [в Астану 29 июля](https://frontendfellows.timepad.ru/event/328848/), но и [30-го в Алма-Ату]((https://frontendfellows.timepad.ru/event/349319/)).

Ну, и немножко начинает проясняться, что мы будем делать в [WSD](https://wsd.events/#calendar). Мы всё ещё планируем провести WSD в Питере, в конце сентября. В Минске уже гораздо более точно, вот уже скоро мы анонсируем даты: это будет конец октября. Потом будет Киев в ноябре и Москва в декабре. Ну как бы логично, в месяц по конференции. Мы сейчас работаем над конкретными датами и конкретными площадками, и что это значит для вас. Это значит, что уже пора подавать заявки на доклады, потому что, в какой-то момент будет поздно. У нас уже были в прошлом году ситуации, когда приходят заявки, а программа уже готова, поэтому успейте.

**Лёша.** А куда подавать-то?

**Вадим.** Куда-куда, к нам. Мы тут везде, от нас не спрятаться: в соцсети, почта, wst@web-standards.ru, Слак, можно на улице, в принципе, подходить, подсовывать записочки с темой доклада, что угодно.

## 03:03 Плагины для Atom

**Вадим.** Я последние несколько лет делал несколько попыток переехать на новый редактор с Sublime, он как-то немножко завял и протух, и хотелось чего-то более активно развивающегося. Я делал четыре попытки переехать на Atom, и наконец-то переехал, всё настроил, всё нормально работает. А тут вот на неделе вышла статья [Atom treasures, a list of Atom plugins I can’t live without](https://medium.com/p/82a64ac391c), в которой перечисляются интересные плагины, без которых, собственно, автор, Денис Брейн, не может жить. И что удивительно, я накопал там много хорошего. Так что внимательно посмотрите, может быть вы тоже много чего хорошего найдёте. Говорят, что Atom медленный, всё плохо, что за дурацкая идея делать медленный браузер внутри редактора, когда вам нужно открывать пятиметровые файлы. Да, много критики на эту тему, в Слаке поднималась дискуссия по мотивам этой статьи. Все пришли к тому, что у Atom достаточно крутое сообщество, и очень крутая, близкая к фронтенду, сумма технологий, на которой всё работает: темы описываются на веб-технологиях, сам браузер работает на веб-технологиях, плагины очень легко писать. Поэтому фронтендерскому сообществу очень полезно иметь что-нибудь подобное.

Кстати, мы ещё на днях напишем новость про то, что вышла консоль на веб-технологиях, т.е. что-то вроде [HyperTerm](https://hyperterm.org/) или терминала, но по моему на Electron или ещё на чём-то, я ещё не разобрался, в общем, расскажешь. А вы, ребята, чем пользуетесь?
**Лёша.** Я пользуюсь Atom, а ты, Антон?

**Антон.** Я пользуюсь Atom, но иногда запускаю WebStorm. У меня постоянно два редактора в работе, потому что, если нужно писать что-то просто с нуля и много, это Atom, а если тебе нужно с чем-то разбираться, то это 100% WebStorm, потому что он позволяет ходить в глубины того, где что вызывается и изучать код. Вот с Atom так не получается, к сожалению.

**Лёша.** Слушайте, а расскажите мне, я до сих пор не понимаю полезность плагина [Atom Minimap](https://atom.io/packages/minimap). Он, вообще, самый популярный считается. В Sublime сразу же есть, и я вижу, как сотни людей без него вообще жить не могут. Вы пользуетесь этой штукой, объясните мне, почему она так важна?

**Антон.** В одним прекрасный день, я понял, что он мне не нужен, и я его отключил. Да, но некоторые пользуются. Он показывает позицию курсора относительно всего документа и типа умеет показывать (неразб., TODO), но, кажется, что в таком масштабе это всё равно не ясно.

**Вадим.** Мне кажется, что популярность этого плагина плохо говорит о ситуации в разработке, потому что, если вам нужен этот плагин, значит у вас очень длинный файл, и значит, что вы что-то делаете неправильно, и что он у вас не помещается в один экран. Попробуйте может быть подумать про модульность какую-то, про всякие отдельные файлы, про сплиты, потому что, если вам приходится ориентироваться в длиннющем файле, значит у вас какой-то Legacy-код, в который вы вынуждены, либо вы неправильно архитектурно решили всё это.

**Лёша.** Больше того, я вот с Антоном согласен, даже если у меня Legacy-код с длинным файлом, я не понимаю, как мне помогает этот плагин. Я же всё равно по вот этому коду… там же ничего не видно, как это мне помогает? Ну в середине файла я нахожусь и что, что мне это даст? Я умею перемещаться по коду и обычными способами. Я вот никогда не понимал этот плагин, вообще, какая-то странная идея.

**Вадим.** У меня такая же история была. Он сначала был включён по умолчанию в Sublime, по-моему, когда я им ещё пользовался, потом я его отключил и, в общем-то, не скучал совершенно. А вот когда я сейчас установил Atom, включил этот плагин осознанно, и он меня иногда бесит, мелькая справа, он и правда отвлекает, а иногда я смотрю и понимаю, что как бы да, я нахожусь в этой части файла и это как бы подсказывает. Бывает, что, допустим, документация, ты пытаешься сориентироваться, где ты находишься, наверное, это даже не для исходников кода, а для документации. Можно по уменьшенной этой карте понять, в какой части находишься и в какой части что находится, какая нужная часть тебе. То есть, ну вот как-то так. Наверное иногда помогает. Но вот я близок к тому, чтобы снова отключить его.

**Антон.** Мне кажется, что это маркетинговый ход какой-то. Он был в Sublime и его сделали для Atom, чтобы людям с Sublime было легче перейти на Atom.

**Лёша.** Вот это похоже на правду. Да, да, да, похоже. А знаете, есть… это какие-то все свистелки, ну совсем фигня, а не плагин, какой-то, я не знаю, красоту наводит, ну что-то не такое важное, а есть плагин очень крутой, я его попытался завести, даже получилось, и выглядит это круто. Он называется [Atom Pair](https://atom.io/packages/atom-pair), и он позволяет внутри редактора Atom удалённым парным программированием заниматься. То есть, мы, например, Вадим, можем его с тобой поднять, открыть какой-нибудь файлик, законнектиться друг с другом, и ты будешь видеть то, что я печатаю у себя в Atom и, например, предлагать свои изменения. А я буду видеть то, что делаешь ты. Прямо внутри редактора, это круто.

**Вадим.** А как мы будем коннектиться?

**Лёша.** Ну, есть специальный сервис. То есть этот плагин работает поверх специального сервиса Push, который будет передавать все изменения между нами и синхронизировать их.

**Вадим.** Я вообще, никогда не понимал идею парного программирования, ну я не настоящий разработчик, я только каску нашёл. Для меня разработка, это такой интимный процесс, что если кто-то сидеть и совать свои руки в мой код, мне будет неловко.

**Антон.** На самом деле это очень крутая техника.

**Вадим.** А как она работает, расскажи в двух словах.

**Антон.** Но это очень круто работает, когда, например, нужно дотягивать людей до определённого уровня, то есть, если разработчик посильнее будет работать рядом с разработчиком послабее, то достаточно быстро они выровняться по коду. Ну, две головы всегда лучше, чем одна, и условно, пишет-то код всегда один, но другой просто говорит, как правильно писать. Один выполняет функцию, условно, печатной машинки, и особо не думает, а думает за него другой. Так гораздо быстрее получается, поскольку тот, кто думает, не отвлекается на то, что чтобы писать. И так очень эффективно писать код. Я сам много раз это пробовал.

**Вадим.** Я почему-то думал, что тот, который обучается, смотрит на то, как пишет код тот, который обучает. А выходит наоборот, да?

**Антон.** Получается, что он в процессе видит то, как он пишет код лучше, чем он смог бы написать его сам, и автоматически запоминает это.

**Лёша.** Вадим, я тебе ещё более знакомый случай скажу. Помнишь летели с какой-то конференции на самолёте, и ты делал там вот эти вот приложения, прогрессивные приложения.

**Вадим.** Да, помню.

**Лёша.** И я там тебе говорил, мол, вот тут в JS можно было чуть по-другому – это был кусочек парного программирования.

**Вадим.** А, да, я свешивался назад через сиденье в самолёте, давал вам свой ноутбук, говорил: «Смотрите, смотрите, я тут JS написал в офлайне». Такое было, да. Это было парное программирование, а я и не заметил.

**Антон.** Вот, да.

**Лёша.** А этот плагин позволяет это делать ещё и удалённо. Это показывает всю мощь внутренних (неразб., TODO) редактора, с помощью которого можно делать не просто свистелки, а прям какую-нибудь крутую штуку. Просто нужно потратить время и сделать.

**Вадим.** Ну, кстати, одна из самых полезных плагинов, которую я поставил за последнее время, для меня был Projects Manager, когда вы не просто открываете папочки из (неразб., TODO) каких-нибудь в Atom, а когда у вас прям внутри есть система проектов, которую вы сохраняете. По-моему, она по умолчанию есть в Sublime, я уже начинаю забывать Sublime, слава Богу, а вот в Atom для этого нужно поставить плагин. Вы нажимаете комбинацию, `Cntrl+cmd+p` и у вас выпадает список с проектами, которые вы сохранили – они открываются в отдельном окне. В общем, получается довольно удобно.

## 10:44 Доступность

**Вадим.** У нас по мотивам новостей про доступность, которые мы пишем в соцсетях, периодически возникают дискуссии про доступность, и знаете, иногда люди приходят интересуются, какие там HTML-теги используются, какие aria-атрибуты расставлять, как сделать, например, переключатель в стиле iOS доступным. Очень интересно получается, и я думал, что все прожженные циники, верстают на дивах и, в общем, плевать хотели, а тут приходят люди и задают интересные вопросы. И, в частности, я заметил такую тенденцию, что люди очень много предполагают. Они такие смотрят и говорят: "Ну, наверное, этот тег доступнее, чем вот этот другой тег… Ну, потому что логичнее кажется. А вот если добавить какой-нибудь атрибут к этой штуке, например `title`, то она сразу станет доступнее, потому что там же есть текст." И на самом деле это немножко порочный путь, потому что, когда мы предполагаем, мы в итоге не тестируем, и очень много предположений оказываются неверными, потому что у нас на самом деле мало опыта, чтобы делать интерфейсы доступными, этим нужно специально заниматься. Хотя то, что люди думают об этом — это уже большой-большой первый шаг. Для того, чтобы тестировать нужны инструменты и на самом деле есть очень много разных плагинов для всяких отладчиков, например, в Chrome можно поставить панель [Accessibility Dev Tools](https://chrome.google.com/webstore/detail/accessibility-developer-t/fpkknkljclfencbdbgkenhalefipecmb?hl=en), можно поставить ещё какую-нибудь панель и другие, конечно, можно. Но вот тут на неделе появилась панелька [ChromeLens](http://chromelens.xyz/), которая позволяет имитировать "цветовую слепоту" прямо на сайте, и, помимо этого, визуально выстраивать маршрут по которому незрячий пользователь передвигается по вашему сайту, т.е. рисовать такую карту табов его по активным элементам. Это помогает не столько (неразб., TODO), сколько понимать как ваши интерфейсы будут выглядеть и как их поведение будет изменяться в зависимости от возможности вашего пользователя…

**Алексей.** Сейчас попробовал запустить его на главной HTML Academy. В принципе он сказал, что все окей, но выдал много варнингов, что неплохо бы почистить текст… Ну, что-то с ссылками ему не понравилось. В общем, штука работает, она даже показывает много примеров в git-репозитории как сделать лучше, т.е. как хорошо бы сделать. В принципе, полезная штука. И да: нужно тестировать, а не предполагать.

**Вадим.** У меня интересный случай связан с этим ChromeLens: я зашёл на сайт и немножко удивился его поведению. У меня дома интернет не супер-быстрый, поэтому я иногда замечаю такой забавный спецэффект, когда заходишь на сайт, а картинка начинает грузиться, как будто тебе 16 лет и ты первый раз в интернете, т.е. она начинает медленно расти сверху-вниз. Это значит, что там, скорее всего, какая-нибудь 4-мегапиксельная картинка вставлена в 100×100, просто она долго грузится и ты визуально видишь как она это делает. И я зашел в инспектор, посмотрел, и действительно, сайт ChromeLens весит почти 5 метров из-за того, что там логотип был вставлен в 100x100 размером 3000×2000px почему-то. И я зашёл в git-репозиторий ChromeLens, кинул issue, мол, ребята, отресайзите эти ваши картинки, приложил снипет с правильным `srcset`, чтобы там можно было ретиновые картинки грузить… Автор тут же пришёл, сказал спасибо, всё запилил. И благодаря тому, что я зануда, люди в интернете будут грузить меньше трафика.

**Алексей.** Прекрасно, оставайся занудой.

## 14:26 Загрузка шрифтов

**Алексей.** Знаешь, есть ещё один зануда, Зак Лезерман, он никак не может успокоится со своими шрифтами. Он написал ещё одну статью про стратегию загрузки шрифтов — это такой собранный гайд всех-всех разных способов, немножко современных, немножко нового того, что он раньше не писал, и везде он привел все преимущества и недостатки, потому что нет супер-способа, который бы работал где угодно, везде нужно решать, что вам больше нужно, т.е. взамен пожертвовав чем-то. Он также рассказал про `<link rel="preload">` и что хорошо бы шрифты класть в эту штуку, она поддерживается только Chrome и Opera. Но мне интересно другое, он много рассказал про свойство `font-display`, которое вообще по идее когда появится нормальная поддержка в браузерах, оно заменит все эти свистопляски с этими подходами для загрузки шрифтов, потому что он подсказывает как браузеру подгружать внешние веб-шрифты. Тут другой вопрос: почему `font-display` совсем не пушат, ведь мы про это говорили ещё в начале года, прошло полгода, уже там гриды делают, сабгриды придумывают что с ними делать, кучу разных сложных технологий делают, а какую-то простую штуку, свойство `font-display`, браузеры как-то вообще не обращают на нее внимание, её даже в Can I Use не добавляют. Есть [тикет 2015 года](https://github.com/Fyrd/caniuse/issues/2001), мол, добавьте свойство `font-display`, чтобы мы могли видеть его поддержку в браузерах. До сих пор тоже нет, всем пофиг что ли?

**Антон.** Может, это просто не такая большая проблема загрузки шрифтов и поэтому не пушат.

**Вадим.** По-моему это сейчас самая большая проблема, мы более менее научились вставлять картинки так, чтобы они не убивали пользовательский трафик и, вообще, сами устройства. Там всякие source-set, picture и прочее. А вот шрифты — это самые тяжелые ресурсы после картинок в вебе. Ну, ладно, видео, картинки, шрифты — хорошо. Видео динамически грузить более менее, т.е. когда мы кликаем на видео, мы понимаем, с чем мы связываемся. Картинки и шрифты нам навязывают, и проблема шрифтов в том, что долгое время не можешь читать текст в современных веб-китах. Они все еще фиговенько (неразб., TODO), т.е. я все ещё вижу на своем iOS белые страницы, прежде чем смогу что-либо прочесть через 5 секунд, а это уже очень много. Видимо поэтому стоит пушить (неразб., TODO)…

**Алексей.** А знаешь, что спецификацию то сделали, но это [спецификация (неразб., TODO)](https://tabatkins.github.io/specs/css-font-display/), которая лежит только у него в git-репозитории, и поэтому её не включили в draft и RTC.

**Вадим.** Понятно, вот в чем дело. Знаешь, можно ведь сделать свойство типа border-radius от которого никому ни тепло ни холодно, а можно сделать свойство, которое нужно (неразб., TODO) настолько, чтобы браузер переставал грузить и показывал (неразб., TODO) шрифты, или наоборот. И вот все эти тайм-ауты, все эти интерфейсные штуки, и это вмешательство в механизм загрузки страниц — там и так все сложно, а тут ещё какие-то шрифты пришли… В общем, я думаю, что вот эта штука мешает внедрению, вот прям вчера…

**Алексей.** Т.е. можно сказать, что реализация в Chromium и Opera есть, т.е. для неё там есть специальный флаг. В Chrome 49 ещё появилась. Но это единственное место, где хоть как-то это реализовано, потому что (неразб., TODO) в Google работает, да?

**Вадим.** Да, они его используют как местного писателя спецификаций.

**Алексей.** Во, поэтому не очень понятно почему самая лучшая стратегия загрузки шрифтов как-то остается все время в сторонке от нашего хай-вея. Причем все ребята кто пишет как лучше загружать шрифты, приводят много способов, а затем в конце приговаривают: "Ну, вот когда появится font-display — все станет хорошо." Т.е. все об этом говорят, но почему-то фича не пушится, это очень странно. При этом, ты говорил, что в Safari плохо (неразб., TODO) шрифты. Они же тоже работают на этом, т.е. например, в Safari 10 этот момент исправили, добавив также WOFF2-шрифты, т.е. у нас осенью появится версия Safari в которой эта штука будет исправлена. Но дальше этого момента (неразб., TODO) пока не хотят.

**Вадим.** Ну, будем пока ждать, мы же терпеливые разработчики, мы же какой-нить полифил напишем, или вот загрузчик как предлагает Зак.

## 19:59 Введение в промисы

**Алексей.** А знаете, у нас кроме Зака есть ещё такая неутомимая… кхм, леди, я не знаю можно так сказать, может меня проклянут все, Ире Адеринокун, она пишет отличные статьи последние пол-года или год. У нее регулярно выходят с одной стороны простые статьи, например, как работает свойство vertical-align, но с другой стороны, она их очень глубоко разбирает, т.е. вот про vertical-align люди узнали очень много разных подробностей. И недавно она, наверное, решила пойти дальше, заняться JavaScript, и выпустила [статью про промисы](https://bitsofco.de/javascript-promises-101/). Мне, кстати, интересно. Ты, Вадим, наверное не очень много JS-кода пишешь, а вот ты — Антон, наверное, много, ну, мне так кажется. Ты уже много пишешь на промисах или у тебя там всё ещё колбэки, или как вы обычно работаете? Или может у вас уже async/await?

**Антон.** Лично я пишу на промисах много. Просто потому что они позволяют организовывать (неразб., TODO) понятный код. Вне последовательности от того, что должно происходить у тебя в коде. Например, если ты пишешь что-то, что должно ходить на файловую систему, делать запросы, потом их обрабатывать, что-то ещё парсить, то без промисов написать это будет в принципе нереально. Вернее, реально, но читать это будет невозможно.

**Алексей.** Т.е. промисы добавили читабельности коду, т.е. они ведь не изменили механизм запросов, верно?

**Антон.** Нет, механизм запросов они, конечно, не меняют, но позволяют каждую итерацию выносить в модули и складывать их в нужном порядке, и их можно, условно, менять местами, если они написаны правильно. Т.е. они также добавляют ещё гибкости коду, т.е. не только читабельность, но и про организацию архитектуры.

**Вадим.** Это все напоминает старый добрый чейнинг из jQuery или из того же Gulp, когда вы можете складывать вещи друг под другом и тут же визуально понимать что за чем выполняется. Действительно, это очень помогает. Я действительно не так много пишу JS-кода, но когда руки доходят до каких-нибудь сервис воркеров, которые, собственно, на промисах и работают (так было в спеке написано) — это, действительно, очень повышает читабельность.

**Алексей.** Знаете, я бы немножко хотел бы накинуть.. Если вы не против?

**Вадим.** Ща-ща, я раскручиваю вентилятор, давай…

**Алексей.** Давай, молодец. Я просто тоже люблю промисы. Многие преподносят промисы, как… Идея в том, что вот у тебя был гавно-код, который выглядел просто как лапша, там всякие колбэк-хэлл и т.д. Есть отличные картинки, где файтер пускает штуку, и у тебя if-ы так выстраиваются красиво. Но речь о том, что раньше код был организован плохо, а промисы пришли и спасли нас, и код стал лучше. Но мне всё кажется, что это какой-то бред, потому что я видел код на промисах, который выглядел ровно также, как колбэк-хэлл. Просто он не индентился вправо, т.е. не становилось больше табов, но это всё время было then-штука, then-штука, then-штука, и эта колбаса могла вырасти в очень-очень большую штуку. И вот ты, Антон, рассказал, что промисы позволяют разнести все это по маленьким кусочкам — модулям, где ты по сути возвращаешь, наверное, промис, а кто-то там один просто дергает их, и код выглядит хорошо. Но ведь согласись, на колбэках тоже можно было так реализовать?

**Антон.** Не все так можно было бы реализовать, вернее, были бы проблемы с интеграцией. Например, представь себе, что тебе нужно пойти (неразб., TODO) почитать большой файл, затем отправить его на сервер, а когда он вернется, его нужно сохранить в другое место (TODO: другим модулем или к другим модулям?). Как минимум, тебе нужно 3 промиса и 3 колбэка. Организовать это будет уже непросто, особенно если чтение или разбор достаточно развесистый. Это правда, что можно написать и так, и так. И можно на промисах написать, условно, говна, но нужно отдавать себе отчет в том, что ты делаешь. Т.е. промисы — это не супер-спасение, но они сильно помогают, т.е. это удобная штука, которой хорошо бы пользоваться раз уж она есть. Кроме того, она позволяет превращать некоторые синхронные модули в асинхронные, что тоже иногда полезно.

**Алексей.** Ну да, я просто вел как раз таки к тому, что промисы — это никакое не спасение от callback hell, вы можете устроить такой же promise hell, т.е. нужно всегда думать головой, и это не значит, что взяв промисы, вы научитесь хорошо строить архитектуру. Вернемся к статье Иры, она как обычно молодец, можно сказать, что она в мельчайших подробностях разобрала работу промисов. И я знаю как обычно новички реагируют на промисы. Им всегда очень страшно трогать их, потому им кажется, что это какая-то магия, и непонятно как она работает. Потому что ты же просто пишешь твой объект.then, функцию передаешь, затем снова then. И непонятно как оно работает, потому что всё "под капотом". Кажется, что все сложно, но вот просто берете, читаете статью, там всё раскладывается в 2-3 метода, и сразу после прочтения вам покажется, что промисы — это очень простая технология. И большое спасибо Ире, потому что она привела в своей статье очень хорошие примеры, очень хорошо показала как они работают. Если вы всё ещё не пробовали промисы, обязательно прочитайте статью и попробуйте.

## 26:16 Векторные эффекты

**Вадим.** На этой неделе всех удивила [статья про векторные эффекты](http://callmenick.com/post/svg-vector-effects). Мы привыкли, что SVG -- масштабируемая графика, мы масштабируем и все увеличивается. А оказывается есть такой векторный эффект с атрибутом non-scalable stroke, и вы можете задать его вашей фигуре и её обводка (stroke) не будет масштабироваться при увеличении. Например, вы задали её размером 2px, то такой она, видимо, и останется в масштабах браузерных пикселей. С одной стороны, звучит круто и неожиданно, а с другой, раз уж мы нарисовали векторную иконку, и хотим, чтобы она масштабировалась, то не очень понятно зачем его применять. Но полезно знать, что оно есть. Я из своего опыта помню связанный с этим юзкейс: когда вы рисуете какую-то графику, например, комикс или любую другую картинку штрихами определенной толщины. Если вся эта картинка-комикс нарисована штрихами одной толщины, то она выглядит естественно, как-будто её нарисовали карандашом одной толщины. И если вы присмотритесь к любой хорошей контурной графике, то она всегда нарисована контурами одной толщины. А если туда воткнуть смасштабированный объект или взятый откуда-то ещё, нарисованный контурами другой толщины, вы сразу почувствуете такой диссонанс, как-будто вас пытаются обмануть, как-будто это не картинка, а неловкий коллаж. Так вот ситуация, когда вам приходится сводить графику из разных источников с, может быть, разной толщиной контуров, или динамически масштабировать объекты с разной толщиной контуров, вы можете сначала привести её к видимым значениям, а затем масштабировать и не париться по поводу того, что картинка выглядит неестественно или неправильно. Немножко узковатый юзкейс, но может получится его применить. Правда, там есть небольшая проблема с поддержкой, по-моему в (неразб., TODO) до сих пор ничего не работает.

**Алексей.** Да да да.

**Вадим.** Но инструментарий знать полезно. Поэкспериментируйте, попробуйте.

**Антон.** Я знаю где это может пригодиться, например, для синхронизации со шрифтами, либо когда иконки используются рядом с шрифтами. У тебя тонкие шрифты и ты хочешь такие же иконки, это иногда проблема. Тебе приходится рисовать иконки нескольких размеров и использовать их (неразб., TODO). Ты можешь (неразб., TODO) иконки, просто их масштабируя и всегда иметь контур одной толщины. Кажется, это может быть полезным.

## 29:10 Кто такой Антон Виноградов?

**Вадим.** Мы закончили с новостями и давайте вернемся к нашему гостю, он уже сидит тут скучает. Мы позвали [Антона](https://www.facebook.com/awinogradov), после того как на авто-пати после недавнего Субботника мы сидели рядом и он сказал: «А чего вы меня в подкаст не зовете?», я говорю: «А пошли». В общем, он с нами тут, Антон давно появился на горизонте с Protein, с какими-то интересными проектами на стыке верстки, графики, программирования и всего такого. Очень такой неожиданный персонаж с набором скилов. Короче, расскажи про себя, Антон.

**Антон.** Я с недавнего времени работаю в Яндексе, занимаюсь там разработкой интерфейсов, как не странно. Пришел туда на направление стыка дизайна и разработки, и будем заниматься именно этим. Собственно, тем же самым я занимался и в Альфа-Лаборатории некоторое время назад. Но там всё было про нулевой старт, там раньше вообще ничего не было и нужно было всё создать с нуля, стандартизировать интерфейсы и сделать такую платформу, чтобы можно было создавать банковские сервисы достаточно быстро.

**Вадим.** У меня сложилось такое впечатление, что ты для Альфа-Лаборатории написал их собственный Bootstrap.

**Антон.** Ну да, примерно так и есть. И мне кажется этого достаточно для проектирования интерфейсов. На самом деле, когда я туда пришёл года 3 назад, там не было такого понятия как фронтенда в принципе, и весь интернет-банк был одним (TODO: Java или JS?)-приложением, и нужно было всё построить. Кажется, мы построили, и нужно было двигаться куда-то дальше.

**Вадим.** Слушай, а джависты, которые там остались, они ж не помнут ваш фронтенд, который вы красиво сделали?

**Антон.** Надеюсь, что нет. Они ж на бэкенде остались, (неразб., TODO).

**Вадим.** Т.е., фронтенд — это на самом деле загородка, которой мы ограждаем бэкендеров от нашего красивого кода, да?

**Антон.** Я думаю, они только рады, что их теперь никто не видит.
В Яндекс я пришел заниматься примерно тем же самым, но здесь уже конечно же есть огромный опыт разработки фронтенда интерфейсов в принципе. Масштаб сильно больше и, кажется, что я могу здесь делать сильно больше, как-то помочь Яндексу, себе и всему миру стать лучше.

**Вадим.** После того же Субботника я поймал Виталю Харисова в перерыве, мы разговорились про события осенью. В частности, речь зашла про верстающих дизайнеров и дизайнящих верстальщиков, и Виталий сказал, что это всё ещё редкая птица, потому что там на сотню дизайнеров в Яндексе, там десяток действительно серьезных разработчиков, которые дизайнеры одновременно и не просто умеют рисовать и разрабатывать, а сочетают такие скилы вместе. Каких ты людей знаешь ещё, публичных, с которыми можно поговорить на эту тему? Доклады какие-нибудь послушать или вообще позвать кого-нибудь выступить.

**Антон.** Вот в Яндексе самые известные -- это [Шеин](https://events.yandex.ru/lib/people/3421690/) и [Ковчий](https://events.yandex.ru/lib/people/403/). Кажется, что они вели несколько лекций про дизайн и про разработку в школах Яндекса. В частности, про персонажей, которые могут и дизайнить, и верстать, обычно это бывшие технические люди, т.е. раньше это был разработчик, который пришёл в дизайн. И вот теперь он использует весь свой технологический опыт, чтобы делать этот дизайн эффективным. Как правило, таких людей можно найти в компаниях, в которых есть большее количество контента, таких людей вряд ли можно найти в какой-нибудь маленькой компании или стартапе, потому что такой набор скилов тебе нужен, когда тебе приходится работать с большим объемом данных и сервисов, и у тебя нет времени, чтобы двигать пиксели, тебе нужно решать конкретную задачу на реальных данных и, скорее всего, с уже существующим дизайном.

**Алексей.** Как ты сам считаешь, насколько вообще эти технические скилы необходимы дизайнерам в их профессии?

**Антон.** Я думаю, это как минимум нужно, чтобы заработать больше денег.

__33:14__

## 39:39 Инструменты для дизайнеров

## 58:13 Расшифровки подкаста
